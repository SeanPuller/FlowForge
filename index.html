<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Forge - Professional Flow Map Texture Painter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #252525;
            --bg-hover: #2a2a2a;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --accent: #ff6b35;
            --accent-hover: #e55a2b;
            --border: #333;
            --success: #4caf50;
            --warning: #ff9800;
            --error: #f44336;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 48px;
            flex-shrink: 0;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .logo-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, var(--accent), #e55a2b);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .header-controls {
            display: flex;
            gap: 0.5rem;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Toolbar */
        .toolbar {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            padding: 1rem 0.5rem;
            width: 60px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .tool-btn {
            width: 48px;
            height: 48px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative;
        }

        .tool-btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
        }

        .tool-btn.active {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }

        .tool-btn svg {
            width: 24px;
            height: 24px;
        }

        .tooltip {
            position: absolute;
            left: 60px;
            background: var(--bg-tertiary);
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            white-space: nowrap;
            font-size: 0.875rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            border: 1px solid var(--border);
        }

        .tool-btn:hover .tooltip {
            opacity: 1;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            background: var(--bg-primary);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-wrapper {
            position: relative;
			/*
            background: repeating-conic-gradient(#1a1a1a 0% 25%, #0f0f0f 0% 50%) 50% / 20px 20px;
			*/
        }

        #flowCanvas {
            display: block;
            cursor: none;
            width: 100%;
            height: 100%;
        }

        #brushCursor {
            position: absolute;
            border: 2px solid rgba(255, 107, 53, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

        /* Right Sidebar */
        .right-sidebar {
            width: 280px;
            display: flex;
            flex-direction: column;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
        }

        /* Properties Panel */
        .properties-panel {
            width: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex: 1;
            min-height: 0;
        }

        .panel-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .property-group {
            margin-bottom: 1.5rem;
        }

        .property-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            display: block;
        }

        .property-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        input[type="range"] {
            flex: 1;
            height: 4px;
            background: var(--bg-tertiary);
            outline: none;
            border-radius: 2px;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
        }

        input[type="number"], select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 4px;
            width: 100%;
        }

        .value-display {
            min-width: 48px;
            text-align: right;
            font-size: 0.875rem;
            color: var(--accent);
        }

        /* Canvas Panel */
        .canvas-panel {
            width: 100%;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
            flex: 0 0 auto;
        }

        /* Layers Panel */
        .layers-panel {
            width: 100%;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        .layers-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .layer-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .layer-item:hover {
            background: var(--bg-hover);
        }

        .layer-item.active {
            border-color: var(--accent);
            background: rgba(255, 107, 53, 0.1);
        }

        .layer-item.locked {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .layer-item.locked::after {
            content: '';
            position: absolute;
            top: 0.5rem;
            right: 2.5rem;
            width: 16px;
            height: 16px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23a0a0a0'%3E%3Cpath d='M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z'/%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
        }

        .layer-thumbnail {
            width: 48px;
            height: 48px;
            background: var(--bg-primary);
            border-radius: 4px;
            border: 1px solid var(--border);
        }

        .layer-info {
            flex: 1;
        }

        .layer-name {
            font-size: 0.875rem;
            font-weight: 500;
        }

        .layer-type {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .layer-visibility {
            width: 24px;
            height: 24px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
        }

        .layer-delete {
            width: 24px;
            height: 24px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            margin-left: 0.25rem;
        }

        .layer-delete:hover {
            color: var(--error);
        }

        /* Buttons */
        .btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }

        .btn-primary:hover {
            background: var(--accent-hover);
            border-color: var(--accent-hover);
        }

        .btn-icon {
            padding: 0.5rem;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Zoom Controls */
        /* Export Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .modal-subtitle {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .form-row {
            display: flex;
            gap: 0.5rem;
        }

        .form-row .form-group {
            flex: 1;
        }

        /* Status Bar */
        .status-bar {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.875rem;
            color: var(--text-secondary);
            height: 32px;
        }

        .status-info {
            display: flex;
            gap: 2rem;
        }

        /* Color Picker */
        .color-picker-wrapper {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .color-preview {
            width: 48px;
            height: 48px;
            border-radius: 4px;
            border: 2px solid var(--border);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .color-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* Flow Visualization */
        .flow-visualization {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .viz-toggle {
            display: flex;
            gap: 0.25rem;
        }

        .viz-btn {
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .viz-btn.active {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .right-sidebar {
                width: 240px;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            
            .toolbar {
                width: 100%;
                height: 60px;
                flex-direction: row;
                padding: 0.5rem;
                overflow-x: auto;
            }
            
            .right-sidebar {
                width: 100%;
                height: auto;
            }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Checkbox styling */
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--accent);
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="logo">
            <div class="logo-icon">F</div>
            <span>Flow Forge</span>
        </div>
        <div class="header-controls">
            <button class="btn btn-icon" onclick="flowMap.undo()" title="Undo">
                <svg fill="currentColor" viewBox="0 0 24 24">
                    <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
                </svg>
            </button>
            <button class="btn btn-icon" onclick="flowMap.redo()" title="Redo">
                <svg fill="currentColor" viewBox="0 0 24 24">
                    <path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"/>
                </svg>
            </button>
            <button class="btn" onclick="flowMap.clearCanvas()">
                <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                </svg>
                Clear
            </button>
            <button class="btn btn-primary" onclick="flowMap.showExportModal()">
                <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                </svg>
                Export
            </button>
        </div>
    </header>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <button class="tool-btn active" data-tool="brush" onclick="flowMap.setTool('brush')">
                <svg fill="currentColor" viewBox="0 0 24 24">
                    <path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34c-.39-.39-1.02-.39-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.02 0-1.41z"/>
                </svg>
                <span class="tooltip">Brush Tool</span>
            </button>
            <button class="tool-btn" data-tool="eraser" onclick="flowMap.setTool('eraser')">
                <svg fill="currentColor" viewBox="0 0 24 24">
                    <path d="M15.14 3c-.51 0-1.02.2-1.41.59L2.59 14.73c-.78.78-.78 2.05 0 2.83L5.03 20H7.66 20v-2H9.66l5.75-5.75c.78-.78.78-2.05 0-2.83L16.55 3.59c-.39-.39-.9-.59-1.41-.59zm0 2.41L19.59 10 17 12.59 13.41 9l1.73-1.73z"/>
                </svg>
                <span class="tooltip">Eraser Tool</span>
            </button>
        </div>

        <!-- Canvas Container -->
        <div class="canvas-container">

            
            <div class="canvas-wrapper">
                <canvas id="flowCanvas" width="1024" height="1024"></canvas>
                <div id="brushCursor"></div>
            </div>
            <div class="flow-visualization">
                <div class="property-label">Visualization</div>
                <div class="viz-toggle">
                    <button class="viz-btn active" onclick="flowMap.setVisualization('flow')">Flow</button>
                    <button class="viz-btn" onclick="flowMap.setVisualization('arrows')">Arrows</button>
                </div>
            </div>
        </div>

        <div class="right-sidebar">
            <!-- Properties Panel -->
            <div class="properties-panel">
                <div class="panel-header">
                    <span>Brush Properties</span>
                </div>
                <div class="panel-content">
                    <div class="property-group">
                        <label class="property-label">Brush Size</label>
                        <div class="property-control">
                            <input type="range" id="brushSize" min="1" max="400" value="60">
                            <span class="value-display" id="brushSizeValue">60px</span>
                        </div>
                    </div>

                    <div class="property-group">
                        <label class="property-label">Flow Strength</label>
                        <div class="property-control">
                            <input type="range" id="flowStrength" min="0" max="100" value="100">
                            <span class="value-display" id="flowStrengthValue">100%</span>
                        </div>
                    </div>

                    <div class="property-group">
                        <label class="property-label">Mouse Direction</label>
                        <div class="property-control">
                            <span class="value-display" id="mouseDirection">0°</span>
                        </div>
                    </div>

                    <div class="property-group">
                        <label class="property-label">Opacity</label>
                        <div class="property-control">
                            <input type="range" id="brushOpacity" min="0" max="100" value="100">
                            <span class="value-display" id="brushOpacityValue">100%</span>
                        </div>
                    </div>

                    <div class="property-group">
                        <label class="property-label">Smoothing</label>
                        <div class="property-control">
                            <input type="range" id="smoothing" min="0" max="100" value="20">
                            <span class="value-display" id="smoothingValue">20%</span>
                        </div>
                    </div>

                    <div class="property-group">
                        <div class="checkbox-wrapper">
                            <input type="checkbox" id="useMouseDirection" checked>
                            <label for="useMouseDirection" class="property-label" style="margin-bottom: 0;">Use Mouse Direction</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Canvas Panel -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <span>Canvas</span>
                </div>
                <div class="panel-content" style="padding-bottom: 0;">
                    <div class="property-group">
                        <label class="property-label">Resolution</label>
                        <select id="canvasResolution" onchange="flowMap.setResolution(this.value)">
                            <option value="32">32 x 32</option>
                            <option value="64">64 x 64</option>
                            <option value="128">128 x 128</option>
                            <option value="256">256 x 256</option>
                            <option value="512">512 x 512</option>
                            <option value="1024" selected>1024 x 1024</option>
                            <option value="2048">2048 x 2048</option>
                            <option value="4096">4096 x 4096</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Layers Panel -->
            <div class="layers-panel">
                <div class="panel-header">
                    <span>Layers</span>
                    <button class="btn btn-icon" onclick="flowMap.addLayer()">
                        <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                        </svg>
                    </button>
                </div>
                <div class="layers-list" id="layersList">
                    <!-- Layers will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="status-info">
            <span>Canvas: <strong id="canvasSize">1024x1024</strong></span>
            <span>Mouse: <strong id="mousePos">0, 0</strong></span>
            <span>Tool: <strong id="currentTool">Brush</strong></span>
            <span>Flow: <strong id="flowVector">0.0, 0.0</strong></span>
        </div>
        <div class="status-info">
            <span>FPS: <strong id="fps">60</strong></span>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Export Flow Map</h2>
                <p class="modal-subtitle">Configure export settings for your flow map texture</p>
            </div>
            
            <div class="form-group">
                <label class="form-label">File Name</label>
                <input type="text" id="exportFileName" value="flowmap" placeholder="Enter filename">
            </div>

            <div class="form-group">
                <label class="form-label">Resolution</label>
                <select id="exportResolution">
                    <option value="32">32 x 32</option>
                    <option value="64">64 x 64</option>
                    <option value="128">128 x 128</option>
                    <option value="256">256 x 256</option>
                    <option value="512">512 x 512</option>
                    <option value="1024" selected>1024 x 1024</option>
                    <option value="2048">2048 x 2048</option>
                    <option value="4096">4096 x 4096</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label">Format</label>
                <select id="exportFormat">
                    <option value="png">PNG (Recommended)</option>
                    <option value="jpg">JPEG</option>
                    <option value="webp">WebP</option>
                    <option value="tga">TGA</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label">Quality</label>
                <input type="range" id="exportQuality" min="0" max="100" value="100">
                <span class="value-display" id="exportQualityValue">100%</span>
            </div>

            <div style="display: flex; gap: 0.5rem; margin-top: 2rem;">
                <button class="btn" onclick="flowMap.closeExportModal()">Cancel</button>
                <button class="btn btn-primary" onclick="flowMap.exportTexture()" style="flex: 1;">
                    Export Texture
                </button>
            </div>
        </div>
    </div>

    <script>
        class FlowMapPainter {
            constructor() {
                this.canvas = document.getElementById('flowCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.brushCursor = document.getElementById('brushCursor');
                
                this.isDrawing = false;
                this.currentTool = 'brush';
                this.brushSize = 60;
                this.flowStrength = 1;
                this.brushOpacity = 1;
                this.smoothing = 0.2;
                this.visualization = 'flow';
                
                // Mouse direction tracking
                this.mouseX = 0;
                this.mouseY = 0;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.mouseVelocityX = 0;
                this.mouseVelocityY = 0;
                this.mouseDirection = 0;
                this.useMouseDirection = true;
                
                this.lastX = 0;
                this.lastY = 0;
                this.history = [];
                this.historyStep = -1;
                this.maxHistory = 50;
                
                // Initialize with two layers: locked background and transparent active layer
                this.layers = [
                    {
                        id: 1,
                        name: 'Background',
                        type: 'background',
                        visible: true,
                        opacity: 1,
                        locked: true,
                        canvas: document.createElement('canvas'),
                        ctx: null
                    },
                    {
                        id: 2,
                        name: 'Flow Layer 1',
                        type: 'direction',
                        visible: true,
                        opacity: 1,
                        locked: false,
                        canvas: document.createElement('canvas'),
                        ctx: null
                    }
                ];
                
                this.currentLayer = 1; // Start with the transparent layer selected
                this.fps = 60;
                this.lastFrameTime = performance.now();
                
                this.init();
            }
            
            init() {
                // Initialize layer canvases
                this.layers.forEach(layer => {
                    layer.canvas.width = this.canvas.width;
                    layer.canvas.height = this.canvas.height;
                    layer.ctx = layer.canvas.getContext('2d');
                    
                    if (layer.type === 'background') {
                        // Set background layer to 0.5, 0.5, 0.0 (RGB: 128, 128, 0)
                        layer.ctx.fillStyle = 'rgb(128, 128, 0)';
                        layer.ctx.fillRect(0, 0, layer.canvas.width, layer.canvas.height);
                    } else {
                        // Other layers get transparent background
                        layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
                    }
                });
                
                this.setupEventListeners();
                window.addEventListener('resize', this.handleResize.bind(this));
                this.handleResize();
                this.updateCanvas();
                this.updateLayersList();
                this.saveHistory();
                this.animate();
            }
            
            setResolution(size) {
                size = parseInt(size);
                const oldWidth = this.canvas.width;
                const oldHeight = this.canvas.height;
                
                // Save current content
                const savedLayers = this.layers.map(layer => {
                    const temp = document.createElement('canvas');
                    temp.width = oldWidth;
                    temp.height = oldHeight;
                    temp.getContext('2d').drawImage(layer.canvas, 0, 0);
                    return temp;
                });
                
                // Resize main canvas
                this.canvas.width = size;
                this.canvas.height = size;
                
                // Resize layers and restore content
                this.layers.forEach((layer, i) => {
                    layer.canvas.width = size;
                    layer.canvas.height = size;
                    layer.ctx = layer.canvas.getContext('2d');
                    
                    // Restore content scaled
                    layer.ctx.drawImage(savedLayers[i], 0, 0, size, size);
                });
                
                // Reset history as dimensions changed
                this.history = [];
                this.historyStep = -1;
                this.saveHistory();
                
                // Update UI
                document.getElementById('canvasSize').textContent = `${size}x${size}`;
                this.updateCanvas();
                this.updateLayersList();
                this.updateBrushCursor();
            }

            handleResize() {
                const container = document.querySelector('.canvas-container');
                const wrapper = document.querySelector('.canvas-wrapper');
                const rect = container.getBoundingClientRect();
                const size = Math.max(0, Math.min(rect.width, rect.height) - 40);
                
                wrapper.style.width = `${size}px`;
                wrapper.style.height = `${size}px`;
                this.updateBrushCursor();
            }

            setupEventListeners() {
                // Canvas events
                this.canvas.addEventListener('mousedown', this.startDrawing.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.stopDrawing.bind(this));
                this.canvas.addEventListener('mouseleave', this.stopDrawing.bind(this));
                this.canvas.addEventListener('mouseenter', this.showBrushCursor.bind(this));
                this.canvas.addEventListener('mouseleave', this.hideBrushCursor.bind(this));
                
                // Touch events
                this.canvas.addEventListener('touchstart', this.handleTouch.bind(this));
                this.canvas.addEventListener('touchmove', this.handleTouch.bind(this));
                this.canvas.addEventListener('touchend', this.stopDrawing.bind(this));
                
                // Property controls
                document.getElementById('brushSize').addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('brushSizeValue').textContent = `${this.brushSize}px`;
                    this.updateBrushCursor();
                });
                
                document.getElementById('flowStrength').addEventListener('input', (e) => {
                    this.flowStrength = parseInt(e.target.value) / 100;
                    document.getElementById('flowStrengthValue').textContent = `${e.target.value}%`;
                });
                
                document.getElementById('brushOpacity').addEventListener('input', (e) => {
                    this.brushOpacity = parseInt(e.target.value) / 100;
                    document.getElementById('brushOpacityValue').textContent = `${e.target.value}%`;
                });
                
                document.getElementById('smoothing').addEventListener('input', (e) => {
                    this.smoothing = parseInt(e.target.value) / 100;
                    document.getElementById('smoothingValue').textContent = `${e.target.value}%`;
                });
                
                document.getElementById('useMouseDirection').addEventListener('change', (e) => {
                    this.useMouseDirection = e.target.checked;
                });
                
                document.getElementById('exportQuality').addEventListener('input', (e) => {
                    document.getElementById('exportQualityValue').textContent = `${e.target.value}%`;
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        switch(e.key) {
                            case 'z':
                                e.preventDefault();
                                if (e.shiftKey) {
                                    this.redo();
                                } else {
                                    this.undo();
                                }
                                break;
                            case 's':
                                e.preventDefault();
                                this.showExportModal();
                                break;
                        }
                    }
                    
                    // Tool shortcuts
                    switch(e.key) {
                        case 'b':
                            this.setTool('brush');
                            break;
                        case 'e':
                            this.setTool('eraser');
                            break;
                    }
                });
            }
            
            showBrushCursor() {
                this.brushCursor.style.display = 'block';
                this.updateBrushCursor();
            }
            
            hideBrushCursor() {
                this.brushCursor.style.display = 'none';
            }
            
			updateBrushCursor() {
                const rect = this.canvas.getBoundingClientRect();
                if (rect.width === 0) return;
                const scale = this.canvas.width / rect.width;
                const brushScale = this.canvas.width / 1024;
				const size = (this.brushSize * brushScale * 2) / scale;
				this.brushCursor.style.width = `${size}px`;
				this.brushCursor.style.height = `${size}px`;
				
				// Update cursor appearance based on tool
				if (this.currentTool === 'eraser') {
					this.brushCursor.style.borderColor = 'rgba(255, 100, 100, 0.8)';
					this.brushCursor.style.boxShadow = '0 0 10px rgba(255, 100, 100, 0.5)';
				} else {
					this.brushCursor.style.borderColor = 'rgba(255, 107, 53, 0.8)';
					this.brushCursor.style.boxShadow = '0 0 10px rgba(255, 107, 53, 0.5)';
				}
			}
            
			handleMouseMove(e) {
				const rect = this.canvas.getBoundingClientRect();
                const scale = this.canvas.width / rect.width;
				this.mouseX = (e.clientX - rect.left) * scale;
				this.mouseY = (e.clientY - rect.top) * scale;

                // Update brush cursor position
                const brushScale = this.canvas.width / 1024;
                const visualSize = (this.brushSize * brushScale * 2) / scale;
                const cursorRadius = visualSize / 2;
                
				this.brushCursor.style.left = `${(e.clientX - rect.left) - cursorRadius}px`;
				this.brushCursor.style.top = `${(e.clientY - rect.top) - cursorRadius}px`;

				// Calculate mouse velocity and direction
				this.mouseVelocityX = this.mouseX - this.lastMouseX;
				this.mouseVelocityY = this.mouseY - this.lastMouseY;
				
				const velocity = Math.sqrt(this.mouseVelocityX ** 2 + this.mouseVelocityY ** 2);
				if (velocity > 0.5) {
					this.mouseDirection = Math.atan2(this.mouseVelocityY, this.mouseVelocityX);
				}
				
				// Update displays
				document.getElementById('mousePos').textContent = `${Math.round(this.mouseX)}, ${Math.round(this.mouseY)}`;
				const degrees = Math.round(this.mouseDirection * 180 / Math.PI);
				document.getElementById('mouseDirection').textContent = `${degrees}°`;
				
				const flowX = (Math.cos(this.mouseDirection) * this.flowStrength).toFixed(2);
				const flowY = (Math.sin(this.mouseDirection) * this.flowStrength).toFixed(2);
				document.getElementById('flowVector').textContent = `${flowX}, ${flowY}`;
				
				if (this.isDrawing) {
					this.draw(e);
				}
				
				this.lastMouseX = this.mouseX;
				this.lastMouseY = this.mouseY;
			}
            
            handleTouch(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' : 
                                                  e.type === 'touchmove' ? 'mousemove' : 'mouseup', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.canvas.dispatchEvent(mouseEvent);
            }
            
            startDrawing(e) {
                // Prevent drawing on locked layers
                if (this.layers[this.currentLayer].locked) {
                    return;
                }
                
                this.isDrawing = true;
                const rect = this.canvas.getBoundingClientRect();
                const scale = this.canvas.width / rect.width;
                this.lastX = (e.clientX - rect.left) * scale;
                this.lastY = (e.clientY - rect.top) * scale;
            }
            
            draw(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scale = this.canvas.width / rect.width;
                const x = (e.clientX - rect.left) * scale;
                const y = (e.clientY - rect.top) * scale;
                
                if (!this.isDrawing) return;
                
                const layer = this.layers[this.currentLayer];
                
                // Don't draw on locked layers
                if (layer.locked) {
                    return;
                }
                
                const ctx = layer.ctx;
                
                // Save the current composite operation
                const currentCompositeOperation = ctx.globalCompositeOperation;
                
                ctx.globalAlpha = this.brushOpacity;
                
                // Scale brush size based on resolution (base 1024)
                const brushScale = this.canvas.width / 1024;
                
                switch(this.currentTool) {
                    case 'brush':
                        this.drawFlowBrush(ctx, x, y, brushScale);
                        break;
                    case 'eraser':
                        this.drawEraser(ctx, x, y, brushScale);
                        break;
                }
                
                // Restore the composite operation
                ctx.globalCompositeOperation = currentCompositeOperation;
                
                this.lastX = x;
                this.lastY = y;
                
                this.updateCanvas();
            }
            
            drawFlowBrush(ctx, x, y, scale) {
                const size = this.brushSize * scale;
                
                // Use mouse direction for flow color if enabled
                let dirX, dirY;
                
                if (this.useMouseDirection) {
                    dirX = this.mouseVelocityX;
                    dirY = this.mouseVelocityY * -1;
                    
                    // Normalize and scale
                    const length = Math.sqrt(dirX * dirX + dirY * dirY);
                    if (length > 0) {
                        dirX = (dirX / length) * this.flowStrength;
                        dirY = (dirY / length) * this.flowStrength;
                    }
                } else {
                    // Use default direction (right)
                    dirX = this.flowStrength;
                    dirY = 0;
                }
                
                // Convert to RGB values (0-255 range)
                // Red channel = X direction, Green channel = Y direction, Blue channel = 0
                const r = Math.floor(128 + dirX * 127);
                const g = Math.floor(128 + dirY * 127);
                const b = 0; // Blue channel set to 0
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${this.flowStrength})`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x - size, y - size, size * 2, size * 2);
            }
            
            drawEraser(ctx, x, y, scale) {
                const size = this.brushSize * scale;
                
                // Set composite operation to erase
                ctx.globalCompositeOperation = 'destination-out';
                
                // Draw eraser stroke
                ctx.beginPath();
                ctx.moveTo(this.lastX, this.lastY);
                ctx.lineTo(x, y);
                ctx.strokeStyle = 'rgba(0,0,0,1)';
                ctx.lineWidth = size * 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
                
                // Also draw a circle for single clicks
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Reset composite operation
                ctx.globalCompositeOperation = 'source-over';
            }
            
            stopDrawing() {
                if (this.isDrawing) {
                    this.isDrawing = false;
                    this.saveHistory();
                }
            }
            
            updateCanvas() {
                // Clear main canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw visible layers in order
                this.layers.forEach(layer => {
                    if (layer.visible) {
                        this.ctx.globalAlpha = layer.opacity;
                        this.ctx.drawImage(layer.canvas, 0, 0);
                    }
                });
                
                this.ctx.globalAlpha = 1;
                
                // Apply visualization overlay
                if (this.visualization === 'arrows') {
                    this.drawFlowArrows();
                }
            }
            
            drawFlowArrows() {
                const baseSize = 1024;
                const scale = this.canvas.width / baseSize;
                const spacing = 32 * scale;
                const arrowSize = 20 * scale;
                const headSize = 5 * scale;
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.5;
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = Math.max(1, 2 * scale);
                
                for (let x = spacing / 2; x < this.canvas.width; x += spacing) {
                    for (let y = spacing / 2; y < this.canvas.height; y += spacing) {
                        const layer = this.layers[this.currentLayer];
                        const pixel = layer.ctx.getImageData(x, y, 1, 1).data;
                        
                        // Read flow from red and green channels
                        const flowX = (pixel[0] - 128) / 128;
                        const flowY = ((pixel[1] - 128) / 128) * - 1;
                        
                        const magnitude = Math.sqrt(flowX * flowX + flowY * flowY);
                        
                        if (magnitude > 0.1) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(x, y);
                            this.ctx.lineTo(x + flowX * arrowSize, y + flowY * arrowSize);
                            this.ctx.stroke();
                            
                            // Arrow head
                            const angle = Math.atan2(flowY, flowX);
                            this.ctx.beginPath();
                            this.ctx.moveTo(x + flowX * arrowSize, y + flowY * arrowSize);
                            this.ctx.lineTo(
                                x + flowX * arrowSize - headSize * Math.cos(angle - Math.PI / 6),
                                y + flowY * arrowSize - headSize * Math.sin(angle - Math.PI / 6)
                            );
                            this.ctx.moveTo(x + flowX * arrowSize, y + flowY * arrowSize);
                            this.ctx.lineTo(
                                x + flowX * arrowSize - headSize * Math.cos(angle + Math.PI / 6),
                                y + flowY * arrowSize - headSize * Math.sin(angle + Math.PI / 6)
                            );
                            this.ctx.stroke();
                        }
                    }
                }
                
                this.ctx.restore();
            }
            
            setTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
                document.getElementById('currentTool').textContent = tool.charAt(0).toUpperCase() + tool.slice(1);
                
                this.updateBrushCursor();
            }
            
            setVisualization(type) {
                this.visualization = type;
                document.querySelectorAll('.viz-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
                this.updateCanvas();
            }
            
            saveHistory() {
                this.historyStep++;
                if (this.historyStep < this.history.length) {
                    this.history.length = this.historyStep;
                }
                
                const layer = this.layers[this.currentLayer];
                this.history.push(layer.ctx.getImageData(0, 0, layer.canvas.width, layer.canvas.height));
                
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                    this.historyStep--;
                }
            }
            
            undo() {
                if (this.historyStep > 0) {
                    this.historyStep--;
                    const layer = this.layers[this.currentLayer];
                    layer.ctx.putImageData(this.history[this.historyStep], 0, 0);
                    this.updateCanvas();
                }
            }
            
            redo() {
                if (this.historyStep < this.history.length - 1) {
                    this.historyStep++;
                    const layer = this.layers[this.currentLayer];
                    layer.ctx.putImageData(this.history[this.historyStep], 0, 0);
                    this.updateCanvas();
                }
            }
            
            clearCanvas() {
                const layer = this.layers[this.currentLayer];
                
                // Don't clear locked background layer
                if (layer.locked) {
                    return;
                }
                
                // Clear to transparent for non-background layers
                layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
                this.updateCanvas();
                this.saveHistory();
            }
            
            addLayer() {
                const newLayer = {
                    id: this.layers.length + 1,
                    name: `Flow Layer ${this.layers.length}`,
                    type: 'direction',
                    visible: true,
                    opacity: 1,
                    locked: false,
                    canvas: document.createElement('canvas'),
                    ctx: null
                };
                
                newLayer.canvas.width = this.canvas.width;
                newLayer.canvas.height = this.canvas.height;
                newLayer.ctx = newLayer.canvas.getContext('2d');
                // New layers get transparent background
                newLayer.ctx.clearRect(0, 0, newLayer.canvas.width, newLayer.canvas.height);
                
                this.layers.push(newLayer);
                this.currentLayer = this.layers.length - 1; // Select the new layer
                this.updateLayersList();
            }
            
            deleteLayer(index) {
                // Don't delete the background layer
                if (this.layers[index].locked) {
                    return;
                }
                
                // Don't delete if there's only one non-locked layer
                const unlockedLayers = this.layers.filter(l => !l.locked);
                if (unlockedLayers.length <= 1) {
                    return;
                }
                
                this.layers.splice(index, 1);
                
                // Adjust current layer index if needed
                if (this.currentLayer >= this.layers.length) {
                    this.currentLayer = this.layers.length - 1;
                } else if (this.currentLayer > index) {
                    this.currentLayer--;
                }
                
                // Ensure current layer is not locked
                if (this.layers[this.currentLayer].locked) {
                    // Find the first unlocked layer
                    for (let i = 0; i < this.layers.length; i++) {
                        if (!this.layers[i].locked) {
                            this.currentLayer = i;
                            break;
                        }
                    }
                }
                
                this.updateCanvas();
                this.updateLayersList();
            }
            
            updateLayersList() {
                const list = document.getElementById('layersList');
                list.innerHTML = '';
                
                this.layers.forEach((layer, index) => {
                    const item = document.createElement('div');
                    item.className = `layer-item ${index === this.currentLayer ? 'active' : ''} ${layer.locked ? 'locked' : ''}`;
                    
                    if (!layer.locked) {
                        item.onclick = () => this.selectLayer(index);
                    }
                    
                    item.innerHTML = `
                        <canvas class="layer-thumbnail" id="layerThumb${layer.id}"></canvas>
                        <div class="layer-info">
                            <div class="layer-name">${layer.name}</div>
                            <div class="layer-type">${layer.type === 'background' ? 'Background' : 'Direction Map'}</div>
                        </div>
                        <button class="layer-visibility" onclick="event.stopPropagation(); flowMap.toggleLayerVisibility(${index})">
                            <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                                ${layer.visible ? 
                                    '<path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>' :
                                    '<path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>'
                                }
                            </svg>
                        </button>
                        ${!layer.locked ? `
                        <button class="layer-delete" onclick="event.stopPropagation(); flowMap.deleteLayer(${index})" title="Delete Layer">
                            <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                            </svg>
                        </button>
                        ` : ''}
                    `;
                    
                    list.appendChild(item);
                    
                    // Update thumbnail
                    const thumb = document.getElementById(`layerThumb${layer.id}`);
                    const thumbCtx = thumb.getContext('2d');
                    thumb.width = 48;
                    thumb.height = 48;
                    
                    // Draw checkerboard for transparent layers
                    thumbCtx.fillStyle = '#1a1a1a';
                    thumbCtx.fillRect(0, 0, 48, 48);
                    thumbCtx.fillStyle = '#252525';
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            if ((i + j) % 2 === 0) {
                                thumbCtx.fillRect(i * 16, j * 16, 16, 16);
                            }
                        }
                    }
                    
                    thumbCtx.drawImage(layer.canvas, 0, 0, 48, 48);
                });
            }
            
            selectLayer(index) {
                // Don't select locked layers
                if (this.layers[index].locked) {
                    return;
                }
                
                this.currentLayer = index;
                this.updateLayersList();
            }
            
            toggleLayerVisibility(index) {
                this.layers[index].visible = !this.layers[index].visible;
                this.updateCanvas();
                this.updateLayersList();
            }
            
            showExportModal() {
                document.getElementById('exportModal').classList.add('active');
            }
            
            closeExportModal() {
                document.getElementById('exportModal').classList.remove('active');
            }
            
            exportTexture() {
                const resolution = parseInt(document.getElementById('exportResolution').value);
                const width = resolution;
                const height = resolution;
                const format = document.getElementById('exportFormat').value;
                const quality = parseInt(document.getElementById('exportQuality').value) / 100;
                const filename = document.getElementById('exportFileName').value || 'flowmap';
                
                // Create export canvas
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = width;
                exportCanvas.height = height;
                const exportCtx = exportCanvas.getContext('2d');
                
                // Draw composite of all layers
                this.layers.forEach(layer => {
                    if (layer.visible) {
                        exportCtx.globalAlpha = layer.opacity;
                        exportCtx.drawImage(layer.canvas, 0, 0, width, height);
                    }
                });
                
                // Export
                exportCanvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${filename}.${format}`;
                    a.click();
                    URL.revokeObjectURL(url);
                    this.closeExportModal();
                }, `image/${format === 'jpg' ? 'jpeg' : format}`, quality);
            }
            
            animate() {
                const now = performance.now();
                const delta = now - this.lastFrameTime;
                this.fps = Math.round(1000 / delta);
                this.lastFrameTime = now;
                
                document.getElementById('fps').textContent = this.fps;
                
                requestAnimationFrame(() => this.animate());
            }
            
            // Utility functions
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }
            
            rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            
            hsvToRgb(h, s, v) {
                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);
                
                switch (i % 6) {
                    case 0: r = v, g = t, b = p; break;
                    case 1: r = q, g = v, b = p; break;
                    case 2: r = p, g = v, b = t; break;
                    case 3: r = p, g = q, b = v; break;
                    case 4: r = t, g = p, b = v; break;
                    case 5: r = v, g = p, b = q; break;
                }
                
                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }
        }
        
        // Initialize the application
        const flowMap = new FlowMapPainter();
    </script>
</body>
</html>